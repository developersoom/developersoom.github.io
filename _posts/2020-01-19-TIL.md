---
layout: post
title: 200119 TIL rxjs 스터디 - 1

permalink: /til/:year/:month/:day/:title/
categories: [1.5막, TIL (Today I Learned), 스터디]
comments: true
---

## rxjs 스터디 - 1

얇고 굵게 완주하는 게 목표인 rxjs 스터디를 시작했다.

### 오늘의 공부 내용

Intro

- 웹 어플리케이션은 상태 머신이다 => 웹 어플리케이션은 상태 머신의 집합이다. 

- 웹의 오류
  - 입력 오류
  - 상태 오류 --> 상태 전파 (by 리액티브 프로그래밍 패러다임)
    - 구성 요소간 의존도가 있는 경우
    - 호출 순서에 의존도가 있는 경우
  - 로직 오류 --> by 함수형 프로그래밍 패러다임 



Ch1 입력 데이터의 오류

- 동기 / 비동기 시점 문제 -> 구조의 일원화. 시간이라는 개념 입장에선 모두 동기
- 시간을 인덱스로 둔 컬렉션(==stream)을 추상화한 클래스 === Observable (==스트림의 구현체)
- 모든 데이터 can be Observable 인스턴스



Ch2 상태 전파 문제

- 상태 변화로 인한 문제점
  - 의존도 있는 구성요소중 하나가 변경되면 나머지도 변경되어야함
  - 구성요소의 상태를 확인하기 위한 의사소통 비용 발생
  - 한 요소에 여러 개의 의존도가 있는 경우 그 반영 여부를 확인하기 위해 직접 관련 요소의 상태를 반영해주어야함 
- 해결책 = 옵저버 패턴
  - Loosely coupling
    - 상태가 변경될 대상 == subject / 상태 변화를 관찰하는 대상 == observer
    - 루즐리 커플링 == 서로 상호작용은 하지만 서로 잘 모른단느 뜻
  - Push & Pull
    - pull = 데이터를 얻고자 하는 대상이 데이터를 직접 가져오는 방식(매번 요청하여 변경사항 확인 필요)
    - push = 의존 관계의 대상(subject)로 부터 데이터를 제공받는 방식 

- rxjs > 옵저버 패턴

  - 기존 옵저버 패턴은 종료 시점을 알 수 없었다. 
  - 에러 전달을 할 수 없었다.
    - 인터페이스의 확장. complete 메소드 & error 메소드 
  - 데이터가 양방향으로 흐르게 되는 경우가 있다. 
    - Observable은 읽기 전용

- 리액티브 프로그래밍 == 데이터 흐름 && 자동으로 전파 

